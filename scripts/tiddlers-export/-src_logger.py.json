{
  "title": "-src_logger.py",
  "text": "## [[Tags]]\n-src_logger.py -tests_test_logger.py [[--- Codigo]]\n\n```python\n\"\"\"\nğŸ“˜ logger.py â€“ Registro estructurado y visual para OpenPages Pipeline\n\nEste mÃ³dulo cumple dos funciones clave:\n1. Registro multilingÃ¼e con salida visual (terminal) para trazabilidad en tiempo real.\n2. Logging estructurado en formato JSONL para trazabilidad semÃ¡ntica y anÃ¡lisis posterior.\n\nIncluye dos tipos de eventos:\n- Eventos generales (clasificaciÃ³n, errores de procesamiento, etc.)\n- Eventos de validaciÃ³n semÃ¡ntica (estructura, resumen, citas...)\n\nğŸ§¬ En la Vuelta #3 se implementa log_validacion(), que permite:\n- Registrar eventos ligados a zonas del documento (abstract, body, references)\n- Clasificar errores por cÃ³digo (E4001â€“E4999)\n- Escribir logs por ejecuciÃ³n y por hash de documento\n\"\"\"\n\nimport os\nimport json\nimport uuid\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom loguru import logger\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n# ğŸŒ Diccionario multilenguaje con emojis amigables\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nMENSAJES = {\n    \"procesar\": {\n        \"es\": \"ğŸ“˜ Procesando: {archivo}\",\n        \"en\": \"ğŸ“˜ Processing: {archivo}\"\n    },\n    \"clasificado\": {\n        \"es\": \"ğŸ“– Clasificado como: {categoria} ({dewey})\",\n        \"en\": \"ğŸ“– Classified as: {categoria} ({dewey})\"\n    },\n    \"export_ok\": {\n        \"es\": \"âœ”ï¸ ExportaciÃ³n completa: [{archivo}]\",\n        \"en\": \"âœ”ï¸ Export completed: [{archivo}]\"\n    },\n    \"warning_meta\": {\n        \"es\": \"âš ï¸ Metadatos incompletos o invÃ¡lidos\",\n        \"en\": \"âš ï¸ Incomplete or invalid metadata\"\n    },\n    \"warning_texto_corto\": {\n        \"es\": \"âš ï¸ Texto extraÃ­do demasiado corto. Archivo omitido.\",\n        \"en\": \"âš ï¸ Extracted text too short. Skipping file.\"\n    },\n    \"error_parse\": {\n        \"es\": \"âŒ Error procesando archivo: {archivo}\",\n        \"en\": \"âŒ Error processing file: {archivo}\"\n    },\n    \"archivo_inaccesible\": {\n        \"es\": \"âŒ Archivo inaccesible o corrupto: {archivo}\",\n        \"en\": \"âŒ Unreadable or corrupt file: {archivo}\"\n    }\n}\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n# âš™ï¸ ConfiguraciÃ³n global para logs\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nLANG = os.getenv(\"LANG\", \"es\")\nLOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"INFO\").upper()\nEXECUTION_ID = os.getenv(\"EXECUTION_ID\", uuid.uuid4().hex)\n\nLOGS_DIR = Path(\"output/logs\")\nLOGS_DIR.mkdir(parents=True, exist_ok=True)\n\ntimestamp = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\nglobal_log_txt = LOGS_DIR / f\"run_{timestamp}.log\"\nglobal_log_jsonl = LOGS_DIR / f\"run_{timestamp}.jsonl\"\n\nlogger.remove()\nlogger.add(global_log_txt, level=LOG_LEVEL, format=\"{time} | {level} | {message}\")\nlogger.add(global_log_jsonl, serialize=True, level=LOG_LEVEL)\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n# ğŸ§© log_evento(): para eventos generales (pipeline, errores)\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ndef log_evento(evento: str, archivo: str = \"\", categoria: str = \"\", dewey: str = \"\", nivel: str = \"INFO\", **extra) -> str:\n    \"\"\"\n    Registra un evento general en consola, archivo .log y .jsonl\n    \"\"\"\n    global LANG\n    LANG = os.getenv(\"LANG\", \"es\")\n    idioma = MENSAJES.get(evento, {}).get(LANG, evento)\n    mensaje = idioma.format(archivo=archivo, categoria=categoria, dewey=dewey)\n\n    log_data = {\n        \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        \"ejecucion\": EXECUTION_ID,\n        \"evento\": evento,\n        \"archivo\": archivo,\n        \"categoria\": categoria,\n        \"dewey\": dewey,\n        \"nivel\": nivel.upper(),\n    }\n\n    # Visual amigable\n    print(mensaje)\n\n    # Log plano\n    try:\n        logger.log(nivel.upper(), mensaje)\n    except Exception as e:\n        print(f\"âŒ Error en log plano: {e}\")\n\n    # Log estructurado\n    try:\n        with open(global_log_jsonl, \"a\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(log_data) + \"\\n\")\n    except Exception as e:\n        print(f\"âŒ Error escribiendo log estructurado: {e}\")\n\n    # Log individual por archivo\n    if archivo:\n        try:\n            archivo_log = LOGS_DIR / f\"{Path(archivo).stem}.log\"\n            with open(archivo_log, \"a\", encoding=\"utf-8\") as f:\n                f.write(f\"{log_data['timestamp']} | {evento.upper()} | {mensaje}\\n\")\n        except Exception as e:\n            print(f\"âŒ Error escribiendo log individual: {e}\")\n\n    return mensaje\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n# ğŸ§¬ log_validacion(): eventos semÃ¡nticos AI-ready\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ndef log_validacion(evento: str, error_code: str, severity: str, zone: str, archivo: str, razones: list, hash: str = \"\", **kwargs):\n    \"\"\"\n    Registra un evento de validaciÃ³n semÃ¡ntica en formato AI-ready:\n    - Incluye cÃ³digo, severidad, zona, hash, y razones\n    - Se escribe tanto en el log global como en un log exclusivo por documento (basado en hash)\n    \"\"\"\n    if evento != \"validation_error\":\n        print(f\"âŒ Evento invÃ¡lido: {evento}\")\n        return\n\n    if not isinstance(razones, list) or not razones:\n        print(f\"âŒ Razones vacÃ­as o mal formateadas para {evento}\")\n        return\n\n    log_data = {\n        \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        \"ejecucion\": EXECUTION_ID,\n        \"evento\": evento,\n        \"error_code\": error_code,\n        \"severity\": severity.upper(),\n        \"zone\": zone,\n        \"archivo\": archivo,\n        \"razones\": razones,\n        \"hash_doc\": hash\n    }\n\n    try:\n        with open(global_log_jsonl, \"a\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(log_data) + \"\\n\")\n    except Exception as e:\n        print(f\"âŒ Error escribiendo validaciÃ³n global: {e}\")\n\n    if hash:\n        try:\n            archivo_hash = LOGS_DIR / f\"{hash}.jsonl\"\n            with open(archivo_hash, \"a\", encoding=\"utf-8\") as f:\n                f.write(json.dumps(log_data) + \"\\n\")\n        except Exception as e:\n            print(f\"âŒ Error escribiendo log por hash: {e}\")\n\n    print(f\"ğŸ§  [{severity.upper()}] [{zone}] {razones[0]}\")\n\n```",
  "tags": "-src_logger.py -tests_test_logger.py [[--- Codigo]]",
  "type": "text/markdown",
  "created": "20250424205039116",
  "modified": "20250424205039118"
}