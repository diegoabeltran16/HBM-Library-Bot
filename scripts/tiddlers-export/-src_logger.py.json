{
  "title": "-src_logger.py",
  "text": "## [[Tags]]\nPython -src_logger.py -tests_test_logger.py [[--- Codigo]]\n\n```python\n# src/logger.py\n\n\"\"\"\nğŸ“˜ Logger persistente para Dewey Pipeline\nRegistra eventos con formato estructurado (.log y .jsonl) y visual (emoji).\nCompatible con trazabilidad por corrida e integraciÃ³n futura.\n\nğŸ§± Estructura del JSON generado (1 lÃ­nea por evento):\n{\n    \"timestamp\": \"2025-04-10T15:42:21.543Z\",\n    \"ejecucion\": \"c78fbccbeed045b5919e8a7e79dd4d73\",\n    \"evento\": \"clasificado\",\n    \"archivo\": \"input/Libro.pdf\",\n    \"categoria\": \"TecnologÃ­a\",\n    \"dewey\": \"600\",\n    \"nivel\": \"INFO\"\n}\n\nğŸ§¬ Para Vuelta #3, se incluye log_validacion() como gen especializado:\n{\n    \"evento\": \"validation_error\",\n    \"error_code\": \"E4001\",\n    \"severity\": \"ERROR\",\n    \"zone\": \"abstract\",\n    \"razones\": [\"Resumen fuera de rango: 54 palabras\"],\n    \"hash_doc\": \"e4a2f3a1...\"\n}\n\"\"\"\n\nimport os\nimport json\nimport uuid\nfrom datetime import datetime\nfrom pathlib import Path\nfrom loguru import logger\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n# ğŸŒ Diccionario multilenguaje con emojis\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nMENSAJES = {\n    \"procesar\": {\n        \"es\": \"ğŸ“˜ Procesando: {archivo}\",\n        \"en\": \"ğŸ“˜ Processing: {archivo}\"\n    },\n    \"clasificado\": {\n        \"es\": \"ğŸ“– Clasificado como: {categoria} ({dewey})\",\n        \"en\": \"ğŸ“– Classified as: {categoria} ({dewey})\"\n    },\n    \"export_ok\": {\n        \"es\": \"âœ”ï¸ ExportaciÃ³n completa: [{archivo}]\",\n        \"en\": \"âœ”ï¸ Export completed: [{archivo}]\"\n    },\n    \"warning_meta\": {\n        \"es\": \"âš ï¸ Metadatos incompletos o invÃ¡lidos\",\n        \"en\": \"âš ï¸ Incomplete or invalid metadata\"\n    },\n    \"warning_texto_corto\": {\n        \"es\": \"âš ï¸ Texto extraÃ­do demasiado corto. Archivo omitido.\",\n        \"en\": \"âš ï¸ Extracted text too short. Skipping file.\"\n    },\n    \"error_parse\": {\n        \"es\": \"âŒ Error procesando archivo: {archivo}\",\n        \"en\": \"âŒ Error processing file: {archivo}\"\n    },\n    \"archivo_inaccesible\": {\n        \"es\": \"âŒ Archivo inaccesible o corrupto: {archivo}\",\n        \"en\": \"âŒ Unreadable or corrupt file: {archivo}\"\n    }\n}\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n# âš™ï¸ ConfiguraciÃ³n global y persistencia\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nLANG = os.getenv(\"LANG\", \"es\")\nLOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"INFO\").upper()\nEXECUTION_ID = os.getenv(\"EXECUTION_ID\", uuid.uuid4().hex)\n\nLOGS_DIR = Path(\"output/logs\")\nLOGS_DIR.mkdir(parents=True, exist_ok=True)\n\ntimestamp = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\nglobal_log_txt = LOGS_DIR / f\"run_{timestamp}.log\"\nglobal_log_jsonl = LOGS_DIR / f\"run_{timestamp}.jsonl\"\n\nlogger.remove()\nlogger.add(global_log_txt, level=LOG_LEVEL, format=\"{time} | {level} | {message}\")\nlogger.add(global_log_jsonl, serialize=True, level=LOG_LEVEL)\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n# ğŸ§© FunciÃ³n principal de logging\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ndef log_evento(evento: str, archivo: str = \"\", categoria: str = \"\", dewey: str = \"\", nivel: str = \"INFO\", **extra) -> str:\n    global LANG\n    LANG = os.getenv(\"LANG\", \"es\")\n    idioma = MENSAJES.get(evento, {}).get(LANG, evento)\n    mensaje = idioma.format(archivo=archivo, categoria=categoria, dewey=dewey)\n\n    # Visual amigable (terminal)\n    print(mensaje)\n\n    # Entrada estructurada\n    log_data = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"ejecucion\": EXECUTION_ID,\n        \"evento\": evento,\n        \"archivo\": archivo,\n        \"categoria\": categoria,\n        \"dewey\": dewey,\n        \"nivel\": nivel.upper(),\n    }\n\n    try:\n        logger.log(nivel.upper(), mensaje)\n    except Exception as e:\n        print(f\"âŒ Error escribiendo en log plano: {e}\")\n\n    try:\n        with open(global_log_jsonl, \"a\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(log_data) + \"\\n\")\n    except Exception as e:\n        print(f\"âŒ Error escribiendo en log JSONL: {e}\")\n\n    if archivo:\n        try:\n            archivo_log = LOGS_DIR / f\"{Path(archivo).stem}.log\"\n            with open(archivo_log, \"a\", encoding=\"utf-8\") as f:\n                f.write(f\"{log_data['timestamp']} | {evento.upper()} | {mensaje}\\n\")\n        except Exception as e:\n            print(f\"âŒ Error escribiendo log individual: {e}\")\n\n    return mensaje\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n# ğŸ§¬ FunciÃ³n para logging de validaciones semÃ¡nticas\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ndef log_validacion(evento: str, error_code: str, severity: str, zone: str, archivo: str, razones: list, hash: str = \"\", **kwargs):\n    \"\"\"\n    Logging estructurado de validaciones semÃ¡nticas.\n    Cada entrada representa un 'evento genÃ©tico' del documento PDF, incluyendo:\n    - CÃ³digo de error (E4001...)\n    - Severidad (INFO, WARNING, ERROR, CRITICAL)\n    - Zona semÃ¡ntica (abstract, body, references)\n    - Mensaje humano-readable\n    - Hash del documento como identificador trazable\n    \"\"\"\n    log_data = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"ejecucion\": EXECUTION_ID,\n        \"evento\": evento,\n        \"error_code\": error_code,\n        \"severity\": severity.upper(),\n        \"zone\": zone,\n        \"archivo\": archivo,\n        \"razones\": razones,\n        \"hash_doc\": hash\n    }\n\n    try:\n        with open(global_log_jsonl, \"a\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(log_data) + \"\\n\")\n    except Exception as e:\n        print(f\"âŒ Error escribiendo validaciÃ³n semÃ¡ntica: {e}\")\n\n    print(f\"[{severity.upper()}] {zone} â†’ {razones[0]}\")\n```",
  "tags": "Python -src_logger.py -tests_test_logger.py [[--- Codigo]]",
  "type": "text/markdown",
  "created": "20250424161220329",
  "modified": "20250424161220329"
}