{
  "title": "-src_logger.py",
  "text": "## [[Tags]]\nPython -src_logger.py -tests_test_logger.py [[--- Codigo]]\n\n```python\n# src/logger.py\n\n\"\"\"\n📘 Logger persistente para Dewey Pipeline\nRegistra eventos con formato estructurado (.log y .jsonl) y visual (emoji).\nCompatible con trazabilidad por corrida e integración futura.\n\n🧱 Estructura del JSON generado (1 línea por evento):\n{\n    \"timestamp\": \"2025-04-10T15:42:21.543Z\",\n    \"ejecucion\": \"c78fbccbeed045b5919e8a7e79dd4d73\",\n    \"evento\": \"clasificado\",\n    \"archivo\": \"input/Libro.pdf\",\n    \"categoria\": \"Tecnología\",\n    \"dewey\": \"600\",\n    \"nivel\": \"INFO\"\n}\n\n🧬 Para Vuelta #3, se incluye log_validacion() como gen especializado:\n{\n    \"evento\": \"validation_error\",\n    \"error_code\": \"E4001\",\n    \"severity\": \"ERROR\",\n    \"zone\": \"abstract\",\n    \"razones\": [\"Resumen fuera de rango: 54 palabras\"],\n    \"hash_doc\": \"e4a2f3a1...\"\n}\n\"\"\"\n\nimport os\nimport json\nimport uuid\nfrom datetime import datetime\nfrom pathlib import Path\nfrom loguru import logger\n\n# ─────────────────────────────────────────────────────────────\n# 🌍 Diccionario multilenguaje con emojis\n# ─────────────────────────────────────────────────────────────\nMENSAJES = {\n    \"procesar\": {\n        \"es\": \"📘 Procesando: {archivo}\",\n        \"en\": \"📘 Processing: {archivo}\"\n    },\n    \"clasificado\": {\n        \"es\": \"📖 Clasificado como: {categoria} ({dewey})\",\n        \"en\": \"📖 Classified as: {categoria} ({dewey})\"\n    },\n    \"export_ok\": {\n        \"es\": \"✔️ Exportación completa: [{archivo}]\",\n        \"en\": \"✔️ Export completed: [{archivo}]\"\n    },\n    \"warning_meta\": {\n        \"es\": \"⚠️ Metadatos incompletos o inválidos\",\n        \"en\": \"⚠️ Incomplete or invalid metadata\"\n    },\n    \"warning_texto_corto\": {\n        \"es\": \"⚠️ Texto extraído demasiado corto. Archivo omitido.\",\n        \"en\": \"⚠️ Extracted text too short. Skipping file.\"\n    },\n    \"error_parse\": {\n        \"es\": \"❌ Error procesando archivo: {archivo}\",\n        \"en\": \"❌ Error processing file: {archivo}\"\n    },\n    \"archivo_inaccesible\": {\n        \"es\": \"❌ Archivo inaccesible o corrupto: {archivo}\",\n        \"en\": \"❌ Unreadable or corrupt file: {archivo}\"\n    }\n}\n\n# ─────────────────────────────────────────────────────────────\n# ⚙️ Configuración global y persistencia\n# ─────────────────────────────────────────────────────────────\nLANG = os.getenv(\"LANG\", \"es\")\nLOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"INFO\").upper()\nEXECUTION_ID = os.getenv(\"EXECUTION_ID\", uuid.uuid4().hex)\n\nLOGS_DIR = Path(\"output/logs\")\nLOGS_DIR.mkdir(parents=True, exist_ok=True)\n\ntimestamp = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\nglobal_log_txt = LOGS_DIR / f\"run_{timestamp}.log\"\nglobal_log_jsonl = LOGS_DIR / f\"run_{timestamp}.jsonl\"\n\nlogger.remove()\nlogger.add(global_log_txt, level=LOG_LEVEL, format=\"{time} | {level} | {message}\")\nlogger.add(global_log_jsonl, serialize=True, level=LOG_LEVEL)\n\n# ─────────────────────────────────────────────────────────────\n# 🧩 Función principal de logging\n# ─────────────────────────────────────────────────────────────\ndef log_evento(evento: str, archivo: str = \"\", categoria: str = \"\", dewey: str = \"\", nivel: str = \"INFO\", **extra) -> str:\n    global LANG\n    LANG = os.getenv(\"LANG\", \"es\")\n    idioma = MENSAJES.get(evento, {}).get(LANG, evento)\n    mensaje = idioma.format(archivo=archivo, categoria=categoria, dewey=dewey)\n\n    # Visual amigable (terminal)\n    print(mensaje)\n\n    # Entrada estructurada\n    log_data = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"ejecucion\": EXECUTION_ID,\n        \"evento\": evento,\n        \"archivo\": archivo,\n        \"categoria\": categoria,\n        \"dewey\": dewey,\n        \"nivel\": nivel.upper(),\n    }\n\n    try:\n        logger.log(nivel.upper(), mensaje)\n    except Exception as e:\n        print(f\"❌ Error escribiendo en log plano: {e}\")\n\n    try:\n        with open(global_log_jsonl, \"a\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(log_data) + \"\\n\")\n    except Exception as e:\n        print(f\"❌ Error escribiendo en log JSONL: {e}\")\n\n    if archivo:\n        try:\n            archivo_log = LOGS_DIR / f\"{Path(archivo).stem}.log\"\n            with open(archivo_log, \"a\", encoding=\"utf-8\") as f:\n                f.write(f\"{log_data['timestamp']} | {evento.upper()} | {mensaje}\\n\")\n        except Exception as e:\n            print(f\"❌ Error escribiendo log individual: {e}\")\n\n    return mensaje\n\n# ─────────────────────────────────────────────────────────────\n# 🧬 Función para logging de validaciones semánticas\n# ─────────────────────────────────────────────────────────────\ndef log_validacion(evento: str, error_code: str, severity: str, zone: str, archivo: str, razones: list, hash: str = \"\", **kwargs):\n    \"\"\"\n    Logging estructurado de validaciones semánticas.\n    Cada entrada representa un 'evento genético' del documento PDF, incluyendo:\n    - Código de error (E4001...)\n    - Severidad (INFO, WARNING, ERROR, CRITICAL)\n    - Zona semántica (abstract, body, references)\n    - Mensaje humano-readable\n    - Hash del documento como identificador trazable\n    \"\"\"\n    log_data = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"ejecucion\": EXECUTION_ID,\n        \"evento\": evento,\n        \"error_code\": error_code,\n        \"severity\": severity.upper(),\n        \"zone\": zone,\n        \"archivo\": archivo,\n        \"razones\": razones,\n        \"hash_doc\": hash\n    }\n\n    try:\n        with open(global_log_jsonl, \"a\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(log_data) + \"\\n\")\n    except Exception as e:\n        print(f\"❌ Error escribiendo validación semántica: {e}\")\n\n    print(f\"[{severity.upper()}] {zone} → {razones[0]}\")\n```",
  "tags": "Python -src_logger.py -tests_test_logger.py [[--- Codigo]]",
  "type": "text/markdown",
  "created": "20250424161220329",
  "modified": "20250424161220329"
}