{
  "title": "-src_logger.py",
  "text": "## [[Tags]]\n-src_logger.py -tests_test_logger.py [[--- Codigo]]\n\n```python\n\"\"\"\n📘 logger.py – Registro estructurado y visual para OpenPages Pipeline\n\nEste módulo cumple dos funciones clave:\n1. Registro multilingüe con salida visual (terminal) para trazabilidad en tiempo real.\n2. Logging estructurado en formato JSONL para trazabilidad semántica y análisis posterior.\n\nIncluye dos tipos de eventos:\n- Eventos generales (clasificación, errores de procesamiento, etc.)\n- Eventos de validación semántica (estructura, resumen, citas...)\n\n🧬 En la Vuelta #3 se implementa log_validacion(), que permite:\n- Registrar eventos ligados a zonas del documento (abstract, body, references)\n- Clasificar errores por código (E4001–E4999)\n- Escribir logs por ejecución y por hash de documento\n\"\"\"\n\nimport os\nimport json\nimport uuid\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom loguru import logger\n\n# ─────────────────────────────────────────────────────────────\n# 🌍 Diccionario multilenguaje con emojis amigables\n# ─────────────────────────────────────────────────────────────\nMENSAJES = {\n    \"procesar\": {\n        \"es\": \"📘 Procesando: {archivo}\",\n        \"en\": \"📘 Processing: {archivo}\"\n    },\n    \"clasificado\": {\n        \"es\": \"📖 Clasificado como: {categoria} ({dewey})\",\n        \"en\": \"📖 Classified as: {categoria} ({dewey})\"\n    },\n    \"export_ok\": {\n        \"es\": \"✔️ Exportación completa: [{archivo}]\",\n        \"en\": \"✔️ Export completed: [{archivo}]\"\n    },\n    \"warning_meta\": {\n        \"es\": \"⚠️ Metadatos incompletos o inválidos\",\n        \"en\": \"⚠️ Incomplete or invalid metadata\"\n    },\n    \"warning_texto_corto\": {\n        \"es\": \"⚠️ Texto extraído demasiado corto. Archivo omitido.\",\n        \"en\": \"⚠️ Extracted text too short. Skipping file.\"\n    },\n    \"error_parse\": {\n        \"es\": \"❌ Error procesando archivo: {archivo}\",\n        \"en\": \"❌ Error processing file: {archivo}\"\n    },\n    \"archivo_inaccesible\": {\n        \"es\": \"❌ Archivo inaccesible o corrupto: {archivo}\",\n        \"en\": \"❌ Unreadable or corrupt file: {archivo}\"\n    }\n}\n\n# ─────────────────────────────────────────────────────────────\n# ⚙️ Configuración global para logs\n# ─────────────────────────────────────────────────────────────\nLANG = os.getenv(\"LANG\", \"es\")\nLOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"INFO\").upper()\nEXECUTION_ID = os.getenv(\"EXECUTION_ID\", uuid.uuid4().hex)\n\nLOGS_DIR = Path(\"output/logs\")\nLOGS_DIR.mkdir(parents=True, exist_ok=True)\n\ntimestamp = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\nglobal_log_txt = LOGS_DIR / f\"run_{timestamp}.log\"\nglobal_log_jsonl = LOGS_DIR / f\"run_{timestamp}.jsonl\"\n\nlogger.remove()\nlogger.add(global_log_txt, level=LOG_LEVEL, format=\"{time} | {level} | {message}\")\nlogger.add(global_log_jsonl, serialize=True, level=LOG_LEVEL)\n\n# ─────────────────────────────────────────────────────────────\n# 🧩 log_evento(): para eventos generales (pipeline, errores)\n# ─────────────────────────────────────────────────────────────\ndef log_evento(evento: str, archivo: str = \"\", categoria: str = \"\", dewey: str = \"\", nivel: str = \"INFO\", **extra) -> str:\n    \"\"\"\n    Registra un evento general en consola, archivo .log y .jsonl\n    \"\"\"\n    global LANG\n    LANG = os.getenv(\"LANG\", \"es\")\n    idioma = MENSAJES.get(evento, {}).get(LANG, evento)\n    mensaje = idioma.format(archivo=archivo, categoria=categoria, dewey=dewey)\n\n    log_data = {\n        \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        \"ejecucion\": EXECUTION_ID,\n        \"evento\": evento,\n        \"archivo\": archivo,\n        \"categoria\": categoria,\n        \"dewey\": dewey,\n        \"nivel\": nivel.upper(),\n    }\n\n    # Visual amigable\n    print(mensaje)\n\n    # Log plano\n    try:\n        logger.log(nivel.upper(), mensaje)\n    except Exception as e:\n        print(f\"❌ Error en log plano: {e}\")\n\n    # Log estructurado\n    try:\n        with open(global_log_jsonl, \"a\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(log_data) + \"\\n\")\n    except Exception as e:\n        print(f\"❌ Error escribiendo log estructurado: {e}\")\n\n    # Log individual por archivo\n    if archivo:\n        try:\n            archivo_log = LOGS_DIR / f\"{Path(archivo).stem}.log\"\n            with open(archivo_log, \"a\", encoding=\"utf-8\") as f:\n                f.write(f\"{log_data['timestamp']} | {evento.upper()} | {mensaje}\\n\")\n        except Exception as e:\n            print(f\"❌ Error escribiendo log individual: {e}\")\n\n    return mensaje\n\n# ─────────────────────────────────────────────────────────────\n# 🧬 log_validacion(): eventos semánticos AI-ready\n# ─────────────────────────────────────────────────────────────\ndef log_validacion(evento: str, error_code: str, severity: str, zone: str, archivo: str, razones: list, hash: str = \"\", **kwargs):\n    \"\"\"\n    Registra un evento de validación semántica en formato AI-ready:\n    - Incluye código, severidad, zona, hash, y razones\n    - Se escribe tanto en el log global como en un log exclusivo por documento (basado en hash)\n    \"\"\"\n    if evento != \"validation_error\":\n        print(f\"❌ Evento inválido: {evento}\")\n        return\n\n    if not isinstance(razones, list) or not razones:\n        print(f\"❌ Razones vacías o mal formateadas para {evento}\")\n        return\n\n    log_data = {\n        \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        \"ejecucion\": EXECUTION_ID,\n        \"evento\": evento,\n        \"error_code\": error_code,\n        \"severity\": severity.upper(),\n        \"zone\": zone,\n        \"archivo\": archivo,\n        \"razones\": razones,\n        \"hash_doc\": hash\n    }\n\n    try:\n        with open(global_log_jsonl, \"a\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(log_data) + \"\\n\")\n    except Exception as e:\n        print(f\"❌ Error escribiendo validación global: {e}\")\n\n    if hash:\n        try:\n            archivo_hash = LOGS_DIR / f\"{hash}.jsonl\"\n            with open(archivo_hash, \"a\", encoding=\"utf-8\") as f:\n                f.write(json.dumps(log_data) + \"\\n\")\n        except Exception as e:\n            print(f\"❌ Error escribiendo log por hash: {e}\")\n\n    print(f\"🧠 [{severity.upper()}] [{zone}] {razones[0]}\")\n\n```",
  "tags": "-src_logger.py -tests_test_logger.py [[--- Codigo]]",
  "type": "text/markdown",
  "created": "20250424205039116",
  "modified": "20250424205039118"
}