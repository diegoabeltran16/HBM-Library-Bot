{
  "title": "-src_validator.py",
  "text": "## [[Tags]]\n-src_validator.py [[--- Codigo]] -tests_test_validator.py\n\n```python\nimport re\nfrom datetime import datetime\nfrom src.logger import log_validacion\nfrom src.utils import calcular_hash_md5\n\ndef validar_documento(\n    texto: str,\n    ruta_pdf: str,\n    hash_doc: str = None,\n    tolerante: bool = False\n) -> tuple[bool, dict]:\n    \"\"\"\n    Ejecuta validaciones sintácticas y semánticas sobre el texto extraído,\n    loggea cada evento pero nunca bloquea la exportación.\n\n    Retorna:\n      - True siempre (validación sólo emite warnings)\n      - info: dict con la clave 'razones' listando los errores detectados\n    \"\"\"\n    errores = []\n\n    # Validaciones sintácticas mínimas\n    if len(texto.strip()) < 10:\n        errores.append(\"Texto vacío o ilegible.\")\n\n    if len(texto.split()) < 150:\n        errores.append(\"Texto demasiado corto (menos de 150 palabras).\")\n\n    # Validaciones semánticas\n    errores += validar_resumen(texto)\n    errores += validar_secciones(texto)\n    errores += validar_citas_referencias(texto)\n\n    # Determinar identificador de documento para logging\n    if not hash_doc:\n        hash_doc = calcular_hash_md5(ruta_pdf)\n\n    # Registrar cada error como evento de validación\n    for error in errores:\n        log_validacion(\n            evento=\"validation_error\",\n            error_code=mapear_codigo(error),\n            severity=clasificar_severidad(error),\n            zone=detectar_zona(error),\n            archivo=ruta_pdf,\n            razones=[error],\n            hash=hash_doc\n        )\n\n    # Nunca bloqueamos la exportación\n    return True, {\"razones\": errores}\n\n\ndef validar_resumen(texto: str) -> list[str]:\n    errores = []\n    match = re.search(r'(?i)^(Resumen|Abstract):\\s*(.+?)(\\n\\n|\\n[A-Z])', texto, re.DOTALL | re.MULTILINE)\n    if not match:\n        errores.append(\"Resumen no encontrado.\")\n    else:\n        resumen = match.group(2)\n        palabras = len(resumen.split())\n        if palabras < 100 or palabras > 250:\n            errores.append(f\"Resumen fuera de rango: {palabras} palabras.\")\n    return errores\n\n\ndef validar_secciones(texto: str) -> list[str]:\n    esperadas = ['Introducción', 'Método', 'Resultados', 'Discusión', 'Referencias']\n    encontradas = re.findall(r'^\\s*(%s)' % '|'.join(esperadas), texto, re.MULTILINE | re.IGNORECASE)\n    encontradas_cap = set(map(str.capitalize, encontradas))\n    faltantes = [sec for sec in esperadas if sec not in encontradas_cap]\n    if faltantes:\n        return [f\"Secciones faltantes: {', '.join(faltantes)}\"]\n    return []\n\n\ndef validar_citas_referencias(texto: str) -> list[str]:\n    if not re.search(r'\\[\\d+\\]|\\([A-Z][a-z]+, \\d{4}\\)', texto):\n        return [\"No se detectaron citas ni referencias.\"]\n    return []\n\n\ndef mapear_codigo(error_msg: str) -> str:\n    msg = error_msg.lower()\n    if \"vacío\" in msg or \"ilegible\" in msg:\n        return \"E4000\"\n    if \"secciones faltantes\" in error_msg:\n        return \"E4001\"\n    if \"resumen\" in error_msg.lower():\n        return \"E4002\"\n    if \"citas\" in msg:\n        return \"E4003\"\n    return \"E4999\"\n\n\ndef clasificar_severidad(error_msg: str) -> str:\n    msg = error_msg.lower()\n    if \"vacío\" in msg or \"ilegible\" in msg:\n        return \"WARNING\"\n    if \"resumen\" in msg:\n        return \"INFO\"\n    if \"secciones faltantes\" in error_msg:\n        return \"INFO\"\n    return \"INFO\"\n\n\ndef detectar_zona(error_msg: str) -> str:\n    if \"resumen\" in error_msg.lower():\n        return \"abstract\"\n    if \"secciones faltantes\" in error_msg:\n        return \"body\"\n    if \"citas\" in error_msg.lower():\n        return \"references\"\n    return \"global\"\n\n```",
  "tags": "-src_validator.py [[--- Codigo]] -tests_test_validator.py",
  "type": "text/markdown",
  "created": "20250424205039129",
  "modified": "20250424205039129"
}