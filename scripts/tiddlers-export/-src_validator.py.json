{
  "title": "-src_validator.py",
  "text": "## [[Tags]]\nPython -src_validator.py [[--- Codigo]]\n\n```python\nimport re\nfrom datetime import datetime\nfrom logger import log_validacion\nfrom utils import calcular_hash_md5\n\ndef validar_documento(texto: str, ruta_pdf: str) -> list:\n    \"\"\"\n    Ejecuta validaciones sintácticas y semánticas sobre el texto extraído,\n    loggea cada evento y devuelve un resumen de errores.\n    \"\"\"\n    errores = []\n\n    # Validaciones sintácticas mínimas\n    if len(texto.strip()) < 10:\n        errores.append(\"Texto vacío o ilegible.\")\n\n    if len(texto.split()) < 150:\n        errores.append(\"Texto demasiado corto (menos de 150 palabras).\")\n\n    # Validaciones semánticas\n    errores += validar_resumen(texto)\n    errores += validar_secciones(texto)\n    errores += validar_citas_referencias(texto)\n\n    # Logging de errores con trazabilidad\n    hash_doc = calcular_hash_md5(ruta_pdf)\n    for error in errores:\n        log_validacion(\n            evento=\"validation_error\",\n            error_code=mapear_codigo(error),\n            severity=clasificar_severidad(error),\n            zone=detectar_zona(error),\n            archivo=ruta_pdf,\n            razones=[error],\n            hash=hash_doc\n        )\n\n    return errores\n\ndef validar_resumen(texto):\n    errores = []\n    match = re.search(r'(?i)^(Resumen|Abstract):\\s*(.+?)(\\n\\n|\\n[A-Z])', texto, re.DOTALL | re.MULTILINE)\n    if not match:\n        errores.append(\"Resumen no encontrado.\")\n    else:\n        resumen = match.group(2)\n        palabras = len(resumen.split())\n        if not (100 <= palabras <= 250):\n            errores.append(f\"Resumen fuera de rango: {palabras} palabras.\")\n    return errores\n\ndef validar_secciones(texto):\n    esperadas = ['Introducción', 'Método', 'Resultados', 'Discusión', 'Referencias']\n    encontradas = re.findall(r'^\\s*(%s)' % '|'.join(esperadas), texto, re.MULTILINE | re.IGNORECASE)\n    faltantes = set(esperadas) - set(map(str.capitalize, encontradas))\n    return [f\"Secciones faltantes: {', '.join(faltantes)}\"] if faltantes else []\n\ndef validar_citas_referencias(texto):\n    if not re.search(r'\\[\\d+\\]|\\([A-Z][a-z]+, \\d{4}\\)', texto):\n        return [\"No se detectaron citas ni referencias.\"]\n    return []\n\ndef mapear_codigo(error_msg):\n    if \"Resumen\" in error_msg:\n        return \"E4002\"\n    if \"Secciones faltantes\" in error_msg:\n        return \"E4001\"\n    if \"citas\" in error_msg:\n        return \"E4003\"\n    if \"vacío\" in error_msg:\n        return \"E4000\"\n    return \"E4999\"\n\ndef clasificar_severidad(error_msg):\n    if \"vacío\" in error_msg:\n        return \"CRITICAL\"\n    if \"Resumen\" in error_msg:\n        return \"WARNING\"\n    if \"Secciones\" in error_msg:\n        return \"ERROR\"\n    return \"INFO\"\n\ndef detectar_zona(error_msg):\n    if \"Resumen\" in error_msg:\n        return \"abstract\"\n    if \"Secciones\" in error_msg:\n        return \"body\"\n    if \"citas\" in error_msg:\n        return \"references\"\n    return \"global\"\n\n```",
  "tags": "Python -src_validator.py [[--- Codigo]]",
  "type": "text/markdown",
  "created": "20250424161220334",
  "modified": "20250424161220334"
}