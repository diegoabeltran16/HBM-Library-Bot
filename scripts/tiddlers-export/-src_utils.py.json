{
  "title": "-src_utils.py",
  "text": "## [[Tags]]\nPython -src_utils.py [[--- Codigo]]\n\n```python\n\"\"\"\nüß© utils.py ‚Äì Funciones auxiliares para el an√°lisis estructural y sem√°ntico de documentos PDF\n\nEste m√≥dulo cumple el rol de \"gen auxiliar\" dentro del pipeline OpenPages.\nProporciona funciones reutilizables que permiten:\n- Evaluar la complejidad visual de un PDF (bloques o escaneado)\n- Detectar posibles f√≥rmulas u objetos no textuales\n- Normalizar texto para matching sem√°ntico\n- Calcular un hash √∫nico (MD5) que act√∫a como identificador gen√©tico del documento\n\nTodas las funciones est√°n dise√±adas para ser:\n‚úîÔ∏è Independientes\n‚úîÔ∏è Trazables\n‚úîÔ∏è Reutilizables\n‚úîÔ∏è Seguras ante errores comunes\n\"\"\"\n\nfrom unidecode import unidecode\nimport fitz  # PyMuPDF\nimport re\nimport hashlib\n\n\ndef es_pdf_complejo(ruta_pdf: str, max_paginas: int = 3, umbral: int = 8) -> bool:\n    \"\"\"\n    Eval√∫a si un PDF es \"complejo\" en su estructura visual.\n\n    Criterios:\n    - Muchos bloques detectados (posible layout complicado: columnas, tablas)\n    - Ning√∫n bloque visible (posible imagen o escaneado)\n\n    Args:\n        ruta_pdf: Ruta local del archivo PDF.\n        max_paginas: N√∫mero de p√°ginas a analizar (default: 3).\n        umbral: Cantidad promedio de bloques para considerarlo complejo.\n\n    Returns:\n        True si el PDF es complejo, False si es \"simple\".\n    \"\"\"\n    try:\n        doc = fitz.open(ruta_pdf)\n    except Exception as e:\n        print(f\"‚ùå Error abriendo PDF: {e}\")\n        return True  # Por defecto, tratamos como complejo si no se puede abrir\n\n    paginas = min(len(doc), max_paginas)\n    total_bloques = 0\n\n    for i in range(paginas):\n        bloques = doc[i].get_text(\"blocks\")\n        total_bloques += len(bloques)\n\n    doc.close()\n\n    if total_bloques == 0:\n        return True  # Escaneado o sin texto detectable\n\n    promedio = total_bloques / paginas\n    return promedio > umbral\n\n\ndef contiene_formula(texto: str) -> bool:\n    \"\"\"\n    Detecta si un bloque de texto contiene f√≥rmulas u objetos sospechosos,\n    usando la proporci√≥n de s√≠mbolos no alfab√©ticos como indicador.\n\n    Tambi√©n filtra textos demasiado cortos.\n\n    Args:\n        texto: Fragmento de texto (p√°rrafo o l√≠nea).\n\n    Returns:\n        True si parece contener f√≥rmula o es sospechoso, False si es texto normal.\n    \"\"\"\n    if not texto or len(texto.strip()) < 10:\n        return True\n\n    simbolos = re.findall(r\"[^a-zA-Z0-9\\s]\", texto)\n    proporcion = len(simbolos) / len(texto)\n\n    return proporcion > 0.3\n\n\ndef normalizar_texto(texto: str) -> str:\n    \"\"\"\n    Limpieza sem√°ntica del texto para b√∫squedas y comparaci√≥n.\n\n    Acciones:\n    - Convierte a min√∫sculas\n    - Elimina acentos y caracteres especiales (via unidecode)\n\n    Args:\n        texto: Cualquier string\n\n    Returns:\n        Texto normalizado, listo para matching sem√°ntico\n    \"\"\"\n    return unidecode(texto.lower())\n\n\ndef calcular_hash_md5(path_pdf: str) -> str:\n    \"\"\"\n    Calcula el hash MD5 √∫nico de un archivo PDF.\n\n    Usado para:\n    - Trazabilidad de documentos\n    - Nombrado de logs\n    - Identificaci√≥n gen√©tica en IA-ready exports\n\n    Args:\n        path_pdf: Ruta absoluta al archivo\n\n    Returns:\n        Cadena hexadecimal (32 caracteres)\n    \"\"\"\n    try:\n        with open(path_pdf, 'rb') as f:\n            contenido = f.read()\n            return hashlib.md5(contenido).hexdigest()\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"‚ö†Ô∏è Archivo no encontrado para hashing: {path_pdf}\")\n\n```",
  "tags": "Python -src_utils.py [[--- Codigo]]",
  "type": "text/markdown",
  "created": "20250424175932282",
  "modified": "20250424175932282"
}