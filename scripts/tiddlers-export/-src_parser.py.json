{
  "title": "-src_parser.py",
  "text": "## [[Tags]]\n-src_parser.py [[--- Codigo]] -tests_test_parser.py\n\n```python\nfrom pathlib import Path\nimport fitz  # PyMuPDF\nimport pdfplumber\nfrom src.cleaner import limpiar_texto\nfrom src.ocr import ocr_completo_inteligente\n\n# ---\n# üì¶ parser.py ‚Äì N√∫cleo de extracci√≥n de texto\n#\n# Este m√≥dulo decide c√≥mo extraer texto desde un PDF:\n# - Si el PDF contiene texto \"normal\", usa PyMuPDF o pdfplumber.\n# - Si detecta que el PDF est√° escaneado (im√°genes), activa el gen OCR.\n#\n# üß† Reflexiones para futuras mutaciones:\n# - ¬øDeber√≠amos permitir forzar el uso de OCR manualmente?\n# - ¬øY si combinamos texto extra√≠do + OCR como capas complementarias?\n# - ¬øPodemos estimar idioma del PDF para OCR m√°s preciso autom√°ticamente?\n\n# Heur√≠stica: si el texto extra√≠do es muy corto, probablemente sea un PDF escaneado\nTHRESHOLD_MIN_CARACTERES = 100\n\n\ndef es_pdf_complejo(ruta_pdf: str) -> bool:\n    \"\"\"\n    Intenta determinar si un PDF est√° compuesto por im√°genes escaneadas\n    mediante un umbral de cantidad m√≠nima de caracteres extra√≠dos.\n\n    ‚ùì ¬øY si el texto es muy corto pero no escaneado? Puede haber falsos positivos.\n    \"\"\"\n    try:\n        with pdfplumber.open(ruta_pdf) as pdf:\n            texto = \" \".join([page.extract_text() or \"\" for page in pdf.pages])\n            return len(texto.strip()) < THRESHOLD_MIN_CARACTERES\n    except Exception:\n        return True  # Si pdfplumber falla, asumimos que es complejo\n\n\ndef extract_with_pdfplumber(ruta_pdf: str) -> str:\n    \"\"\"Extrae texto desde PDF usando pdfplumber (m√°s fiel al layout).\"\"\"\n    with pdfplumber.open(ruta_pdf) as pdf:\n        return \"\\n\".join([page.extract_text() or \"\" for page in pdf.pages])\n\n\ndef extract_with_pymupdf(ruta_pdf: str) -> str:\n    \"\"\"Extrae texto con PyMuPDF, muy r√°pido pero menos preciso con columnas o f√≥rmulas.\"\"\"\n    doc = fitz.open(ruta_pdf)\n    return \"\\n\".join([page.get_text(\"text\") for page in doc])\n\n\ndef extract_text(ruta_pdf: str) -> str:\n    \"\"\"\n    Ruta principal de extracci√≥n. Intenta lo m√°s eficiente primero,\n    y recurre al OCR solo si es necesario.\n\n    üîÅ Este enfoque mantiene el rendimiento sin sacrificar precisi√≥n cuando se requiere.\n    \"\"\"\n    texto_crudo = \"\"\n\n    if es_pdf_complejo(ruta_pdf):\n        try:\n            texto_crudo = extract_with_pdfplumber(ruta_pdf)\n            if not texto_crudo.strip():\n                raise ValueError(\"Sin texto extra√≠do con pdfplumber\")\n        except Exception:\n            texto_crudo = ocr_completo_inteligente(ruta_pdf)\n    else:\n        texto_crudo = extract_with_pymupdf(ruta_pdf)\n        if not texto_crudo.strip():\n            texto_crudo = ocr_completo_inteligente(ruta_pdf)\n\n    return limpiar_texto(texto_crudo)\n```",
  "tags": "-src_parser.py [[--- Codigo]] -tests_test_parser.py",
  "type": "text/markdown",
  "created": "20250424205039122",
  "modified": "20250424205039122"
}