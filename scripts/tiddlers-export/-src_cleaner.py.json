{
  "title": "-src_cleaner.py",
  "text": "## [[Tags]]\n-src_cleaner.py [[--- Codigo]] -tests_test_cleaner.py [[ğŸŒ€2ï¸âƒ£ Limpieza avanzada]] [[ğŸŒ€1ï¸âƒ£ Limpieza y PreparaciÃ³n de Texto]]\n\n```python\n# src/cleaner.py\n\nimport re\nimport unicodedata\n\n# ğŸ”§ Lista de sÃ­mbolos decorativos considerados como \"ruido visual\"\nSIMBOLOS_RUIDO = {'----', '***', '///', '...', '__', '==', '~~~', '====='}\n\n# ğŸ”¹ 1. Normaliza caracteres Unicode a forma NFC\ndef normalizar_unicode(texto):\n    \"\"\"\n    Normaliza caracteres a una forma estÃ¡ndar para evitar errores de codificaciÃ³n.\n    \"\"\"\n    return unicodedata.normalize(\"NFC\", texto)\n\n# ğŸ”¹ 2. Elimina lÃ­neas vacÃ­as o compuestas solo por sÃ­mbolos decorativos\ndef eliminar_lineas_ruido(texto):\n    \"\"\"\n    Filtra lÃ­neas que son solo sÃ­mbolos, guiones, etc.\n    \"\"\"\n    lineas_limpias = []\n    for linea in texto.split('\\n'):\n        strip = linea.strip()\n        if not strip:\n            continue\n        if strip in SIMBOLOS_RUIDO:\n            continue\n        if re.match(r'^[\\-\\*\\.\\|\\\\_=~]{3,}$', strip):\n            continue\n        if len(strip) < 3 and not strip.isalpha():\n            continue\n        lineas_limpias.append(linea)\n    return '\\n'.join(lineas_limpias)\n\n# ğŸ”¹ 3. HeurÃ­stica bÃ¡sica para detectar encabezados o tÃ­tulos\ndef detectar_encabezado(linea):\n    \"\"\"\n    Detecta si una lÃ­nea es un encabezado usando heurÃ­sticas comunes.\n    \"\"\"\n    if linea.isupper() and len(linea.split()) < 10:\n        return True\n    if re.match(r'^\\d+(\\.\\d+)*\\s+', linea):\n        return True\n    if re.search(r'\\b(Resumen|IntroducciÃ³n|ConclusiÃ³n|Referencias)\\b', linea, re.IGNORECASE):\n        return True\n    return False\n\n# ğŸ”¹ 4. Marca lÃ­neas detectadas como encabezados con sintaxis Markdown (##)\ndef agregar_markdown_headers(texto):\n    \"\"\"\n    Convierte encabezados detectados en encabezados Markdown (nivel 2).\n    \"\"\"\n    lineas = texto.split('\\n')\n    nuevas = []\n    for linea in lineas:\n        if detectar_encabezado(linea):\n            nuevas.append(f\"## {linea.strip()}\")\n        else:\n            nuevas.append(linea)\n    return '\\n'.join(nuevas)\n\n# ğŸ”¹ 5. Limpieza general: saltos, espacios y saltos semÃ¡nticos entre pÃ¡rrafos\ndef limpiar_texto(texto):\n    \"\"\"\n    Elimina saltos de lÃ­nea innecesarios, normaliza espacios y mejora legibilidad.\n    \"\"\"\n    texto = texto.replace('\\r\\n', '\\n')\n    texto = re.sub(r'(?<=[a-z0-9\\.\\)])\\n(?=[A-Z])', '\\n\\n', texto)  # salto entre frases conectadas\n    texto = re.sub(r'\\n{3,}', '\\n\\n', texto)  # mÃ¡ximo 2 saltos seguidos\n    texto = re.sub(r'[ \\t]+', ' ', texto)\n    texto = re.sub(r' *\\n *', '\\n', texto)\n    return texto.strip()\n\n# ğŸ”¹ 6. Pipeline principal de limpieza, configurable por flags\ndef limpiar_texto_completo(texto, modo_md=False, filtrar_ruido=True):\n    \"\"\"\n    Ejecuta la limpieza completa con opciones para markdown y filtrado de ruido.\n\n    Args:\n        texto (str): El texto a limpiar.\n        modo_md (bool): Si True, convierte encabezados en ## estilo Markdown.\n        filtrar_ruido (bool): Si True, elimina lÃ­neas de bajo valor visual.\n\n    Returns:\n        str: El texto limpio y procesado.\n    \"\"\"\n    texto = normalizar_unicode(texto)\n    if filtrar_ruido:\n        texto = eliminar_lineas_ruido(texto)\n    texto = limpiar_texto(texto)\n    if modo_md:\n        texto = agregar_markdown_headers(texto)\n    return texto\n\n```",
  "tags": "-src_cleaner.py [[--- Codigo]] -tests_test_cleaner.py [[ğŸŒ€2ï¸âƒ£ Limpieza avanzada]] [[ğŸŒ€1ï¸âƒ£ Limpieza y PreparaciÃ³n de Texto]]",
  "type": "text/markdown",
  "created": "20250424205039103",
  "modified": "20250424205039103"
}